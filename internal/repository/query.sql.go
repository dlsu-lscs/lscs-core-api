// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package repository

import (
	"context"
	"database/sql"
)

const checkAllowedOriginExists = `-- name: CheckAllowedOriginExists :one
SELECT EXISTS(SELECT 1 FROM api_keys WHERE allowed_origin = ? AND is_dev = false)
`

func (q *Queries) CheckAllowedOriginExists(ctx context.Context, allowedOrigin sql.NullString) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkAllowedOriginExists, allowedOrigin)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkEmailIfMember = `-- name: CheckEmailIfMember :one
SELECT email FROM members WHERE email = ?
`

func (q *Queries) CheckEmailIfMember(ctx context.Context, email string) (string, error) {
	row := q.db.QueryRowContext(ctx, checkEmailIfMember, email)
	err := row.Scan(&email)
	return email, err
}

const checkIdIfMember = `-- name: CheckIdIfMember :one
SELECT id FROM members WHERE id = ?
`

func (q *Queries) CheckIdIfMember(ctx context.Context, id int32) (int32, error) {
	row := q.db.QueryRowContext(ctx, checkIdIfMember, id)
	err := row.Scan(&id)
	return id, err
}

const deleteAPIKey = `-- name: DeleteAPIKey :exec
DELETE FROM api_keys WHERE member_email = ? LIMIT 1
`

func (q *Queries) DeleteAPIKey(ctx context.Context, memberEmail string) error {
	_, err := q.db.ExecContext(ctx, deleteAPIKey, memberEmail)
	return err
}

const getAPIKeyInfo = `-- name: GetAPIKeyInfo :one
SELECT api_key_id, member_email, api_key_hash, project, allowed_origin, is_dev, is_admin, created_at, expires_at FROM api_keys WHERE api_key_hash = ?
`

func (q *Queries) GetAPIKeyInfo(ctx context.Context, apiKeyHash string) (ApiKey, error) {
	row := q.db.QueryRowContext(ctx, getAPIKeyInfo, apiKeyHash)
	var i ApiKey
	err := row.Scan(
		&i.ApiKeyID,
		&i.MemberEmail,
		&i.ApiKeyHash,
		&i.Project,
		&i.AllowedOrigin,
		&i.IsDev,
		&i.IsAdmin,
		&i.CreatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const getAPIKeyInfoWithEmail = `-- name: GetAPIKeyInfoWithEmail :one
SELECT api_key_id, member_email, api_key_hash, project, allowed_origin, is_dev, is_admin, created_at, expires_at FROM api_keys WHERE member_email = ?
`

func (q *Queries) GetAPIKeyInfoWithEmail(ctx context.Context, memberEmail string) (ApiKey, error) {
	row := q.db.QueryRowContext(ctx, getAPIKeyInfoWithEmail, memberEmail)
	var i ApiKey
	err := row.Scan(
		&i.ApiKeyID,
		&i.MemberEmail,
		&i.ApiKeyHash,
		&i.Project,
		&i.AllowedOrigin,
		&i.IsDev,
		&i.IsAdmin,
		&i.CreatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const getAllAPIKeyHashes = `-- name: GetAllAPIKeyHashes :many
SELECT api_key_hash FROM api_keys
`

func (q *Queries) GetAllAPIKeyHashes(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getAllAPIKeyHashes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var api_key_hash string
		if err := rows.Scan(&api_key_hash); err != nil {
			return nil, err
		}
		items = append(items, api_key_hash)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCommittees = `-- name: GetAllCommittees :many
SELECT c.committee_id, c.committee_name, c.committee_head, c.division_id FROM committees c
`

func (q *Queries) GetAllCommittees(ctx context.Context) ([]Committee, error) {
	rows, err := q.db.QueryContext(ctx, getAllCommittees)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Committee
	for rows.Next() {
		var i Committee
		if err := rows.Scan(
			&i.CommitteeID,
			&i.CommitteeName,
			&i.CommitteeHead,
			&i.DivisionID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllDivisions = `-- name: GetAllDivisions :many
SELECT d.division_id, d.division_name, d.division_head FROM divisions d
`

func (q *Queries) GetAllDivisions(ctx context.Context) ([]Division, error) {
	rows, err := q.db.QueryContext(ctx, getAllDivisions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Division
	for rows.Next() {
		var i Division
		if err := rows.Scan(&i.DivisionID, &i.DivisionName, &i.DivisionHead); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEmailsInAPIKey = `-- name: GetEmailsInAPIKey :many
SELECT member_email FROM api_keys
`

func (q *Queries) GetEmailsInAPIKey(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getEmailsInAPIKey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var member_email string
		if err := rows.Scan(&member_email); err != nil {
			return nil, err
		}
		items = append(items, member_email)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMemberInfo = `-- name: GetMemberInfo :one
SELECT 
  m.id, m.email, m.full_name, m.nickname, 
  c.committee_id, c.committee_name, 
  d.division_id, d.division_name,
  p.position_id, p.position_name,
  h.name as house_name,
  m.contact_number, m.college, m.program,
  m.interests, m.discord, m.fb_link, m.telegram
FROM members m
LEFT JOIN committees c ON m.committee_id = c.committee_id
LEFT JOIN divisions d ON c.division_id = d.division_id
LEFT JOIN positions p ON m.position_id = p.position_id
LEFT JOIN houses h ON m.house_id = h.id
WHERE m.email = ?
`

type GetMemberInfoRow struct {
	ID            int32
	Email         string
	FullName      string
	Nickname      sql.NullString
	CommitteeID   sql.NullString
	CommitteeName sql.NullString
	DivisionID    sql.NullString
	DivisionName  sql.NullString
	PositionID    sql.NullString
	PositionName  sql.NullString
	HouseName     sql.NullString
	ContactNumber sql.NullString
	College       sql.NullString
	Program       sql.NullString
	Interests     sql.NullString
	Discord       sql.NullString
	FbLink        sql.NullString
	Telegram      sql.NullString
}

func (q *Queries) GetMemberInfo(ctx context.Context, email string) (GetMemberInfoRow, error) {
	row := q.db.QueryRowContext(ctx, getMemberInfo, email)
	var i GetMemberInfoRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.FullName,
		&i.Nickname,
		&i.CommitteeID,
		&i.CommitteeName,
		&i.DivisionID,
		&i.DivisionName,
		&i.PositionID,
		&i.PositionName,
		&i.HouseName,
		&i.ContactNumber,
		&i.College,
		&i.Program,
		&i.Interests,
		&i.Discord,
		&i.FbLink,
		&i.Telegram,
	)
	return i, err
}

const getMemberInfoById = `-- name: GetMemberInfoById :one
SELECT 
  m.id, m.email, m.full_name, m.nickname, 
  c.committee_id, c.committee_name, 
  d.division_id, d.division_name,
  p.position_id, p.position_name,
  h.name as house_name,
  m.contact_number, m.college, m.program,
  m.interests, m.discord, m.fb_link, m.telegram
FROM members m
LEFT JOIN committees c ON m.committee_id = c.committee_id
LEFT JOIN divisions d ON c.division_id = d.division_id
LEFT JOIN positions p ON m.position_id = p.position_id
LEFT JOIN houses h ON m.house_id = h.id
WHERE m.id = ?
`

type GetMemberInfoByIdRow struct {
	ID            int32
	Email         string
	FullName      string
	Nickname      sql.NullString
	CommitteeID   sql.NullString
	CommitteeName sql.NullString
	DivisionID    sql.NullString
	DivisionName  sql.NullString
	PositionID    sql.NullString
	PositionName  sql.NullString
	HouseName     sql.NullString
	ContactNumber sql.NullString
	College       sql.NullString
	Program       sql.NullString
	Interests     sql.NullString
	Discord       sql.NullString
	FbLink        sql.NullString
	Telegram      sql.NullString
}

func (q *Queries) GetMemberInfoById(ctx context.Context, id int32) (GetMemberInfoByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getMemberInfoById, id)
	var i GetMemberInfoByIdRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.FullName,
		&i.Nickname,
		&i.CommitteeID,
		&i.CommitteeName,
		&i.DivisionID,
		&i.DivisionName,
		&i.PositionID,
		&i.PositionName,
		&i.HouseName,
		&i.ContactNumber,
		&i.College,
		&i.Program,
		&i.Interests,
		&i.Discord,
		&i.FbLink,
		&i.Telegram,
	)
	return i, err
}

const listMembers = `-- name: ListMembers :many
SELECT
    m.id,
    m.full_name,
    m.nickname,
    m.email,
    m.telegram,
    m.position_id,
    m.committee_id,
    m.college,
    m.program,
    m.discord,
    m.interests,
    m.contact_number,
    m.fb_link,
    h.name as house_name
FROM members m
LEFT JOIN houses h ON m.house_id = h.id
ORDER BY m.email
`

type ListMembersRow struct {
	ID            int32
	FullName      string
	Nickname      sql.NullString
	Email         string
	Telegram      sql.NullString
	PositionID    sql.NullString
	CommitteeID   sql.NullString
	College       sql.NullString
	Program       sql.NullString
	Discord       sql.NullString
	Interests     sql.NullString
	ContactNumber sql.NullString
	FbLink        sql.NullString
	HouseName     sql.NullString
}

func (q *Queries) ListMembers(ctx context.Context) ([]ListMembersRow, error) {
	rows, err := q.db.QueryContext(ctx, listMembers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListMembersRow
	for rows.Next() {
		var i ListMembersRow
		if err := rows.Scan(
			&i.ID,
			&i.FullName,
			&i.Nickname,
			&i.Email,
			&i.Telegram,
			&i.PositionID,
			&i.CommitteeID,
			&i.College,
			&i.Program,
			&i.Discord,
			&i.Interests,
			&i.ContactNumber,
			&i.FbLink,
			&i.HouseName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const storeAPIKey = `-- name: StoreAPIKey :exec
INSERT INTO api_keys (
    member_email,
    api_key_hash,
    project,
    allowed_origin,
    is_dev,
    is_admin,
    expires_at
) VALUES (
    ?, ?, ?, ?, ?, ?, ?
)
`

type StoreAPIKeyParams struct {
	MemberEmail   string
	ApiKeyHash    string
	Project       string
	AllowedOrigin sql.NullString
	IsDev         bool
	IsAdmin       bool
	ExpiresAt     sql.NullTime
}

func (q *Queries) StoreAPIKey(ctx context.Context, arg StoreAPIKeyParams) error {
	_, err := q.db.ExecContext(ctx, storeAPIKey,
		arg.MemberEmail,
		arg.ApiKeyHash,
		arg.Project,
		arg.AllowedOrigin,
		arg.IsDev,
		arg.IsAdmin,
		arg.ExpiresAt,
	)
	return err
}
